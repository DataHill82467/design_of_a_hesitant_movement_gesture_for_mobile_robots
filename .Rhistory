geom_histogram(binwidth= 0.2) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(),
axis.text = element_text(size=12), axis.title = element_text(size=13), legend.position="top", legend.title = element_blank(),
legend.spacing.x = unit(0.2, 'cm'), legend.text = element_text(size=12), axis.line.x = element_line(color="black", size = 0.5))
ggplot(data = data, aes(x = Botime, fill = factor(data$Age))) +
geom_histogram(binwidth= 0.2) +
#scale_fill_manual(values=c("#d49f00", "#75A315", "#2a9f55")) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(),
axis.text = element_text(size=12), axis.title = element_text(size=13), legend.position="top", legend.title = element_blank(),
legend.spacing.x = unit(0.2, 'cm'), legend.text = element_text(size=12), axis.line.x = element_line(color="black", size = 0.5))
#Histogram
plot.new()
nf <- layout(mat = matrix(c(1,2),2,1, byrow=TRUE),  height = c(1,3))
par(fig=c(0,0.8,0,0.8), new=TRUE)
hist(data$Botime, breaks = seq(0, 4.4, by=0.2), xlim=c(0,4.4), xlab = "Back-off time [s]", main="Back-off time")
par(fig=c(0,0.8,0.55,1), new=TRUE)
boxplot(data$Botime, horizontal=TRUE,  outline=FALSE, ylim = c(0,4.4), notch = TRUE)
# Histogram with normal distribution
# https://stackoverflow.com/questions/20078107/overlay-normal-curve-to-histogram-in-r
#' @noRd
#' @exportMethod hist.default
#' @export
hist.default <- function(x,
breaks = "Sturges",
freq = NULL,
include.lowest = TRUE,
normalcurve = TRUE,
right = TRUE,
density = NULL,
angle = 45,
col = NULL,
border = NULL,
#main = paste("Histogram of", xname),
main = NULL,
ylim = NULL,
xlab = xname,
ylab = NULL,
axes = TRUE,
plot = TRUE,
labels = FALSE,
warn.unused = TRUE,
...)  {
# https://stackoverflow.com/a/20078645/4575331
xname <- paste(deparse(substitute(x), 500), collapse = "\n")
suppressWarnings(
h <- graphics::hist.default(
x = x,
breaks = breaks,
freq = freq,
include.lowest = include.lowest,
right = right,
density = density,
angle = angle,
col = col,
border = border,
main = main,
ylim = ylim,
xlab = xlab,
ylab = ylab,
axes = axes,
plot = plot,
labels = labels,
warn.unused = warn.unused,
...
)
)
if (normalcurve == TRUE & plot == TRUE) {
x <- x[!is.na(x)]
xfit <- seq(min(x), max(x), length = 40)
yfit <- dnorm(xfit, mean = mean(x), sd = sd(x))
if (isTRUE(freq) | (is.null(freq) & is.null(density))) {
yfit <- yfit * diff(h$mids[1:2]) * length(x)
}
lines(xfit, yfit, col = "black", lwd = 2)
}
if (plot == TRUE) {
invisible(h)
} else {
h
}
}
plot.new()
nf <- layout(mat = matrix(c(1,2),2,1, byrow=TRUE),  height = c(1,3))
par(fig=c(0,0.8,0,0.8), new=TRUE)
hist(data$Botime, breaks = seq(0, 4.4, by=0.2), xlim=c(0,4.4), xlab = "Back-off time [s]")
par(fig=c(0,0.8,0.55,1), new=TRUE)
boxplot(data$Botime, horizontal=TRUE,  outline=FALSE, ylim = c(0,4.4), notch = TRUE)
############## Robotlength -> Back-Off time ##############
###############################################################
ggplot(data = data, aes(y = Botime, x = Robotlength)) +
geom_point(alpha = 0.4, shape = 16, size=2) +
#geom_line(aes(x = Rlength, y = bo), color = "red", size=1.5, alpha = 0.5) +
geom_boxplot(data=data, aes(y = Botime, group = Robotcategory), notch=TRUE, color="black", fill='#0065BD' , alpha = 0.9, outlier.colour="black") +
#stat_summary(fun.y="mean", geom="point", shape=21, size=4, fill="#f2a10c", alpha = 1, aes(y=Bolength, group=Robotcategory)) +
#stat_summary(fun.y = mean, geom = "line", color = "#455B8F", aes(group="Robotcategory")) +
labs(y="Back-off time [s]") +
labs(x="Robot length [m]") +
#theme_bw()
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(),
axis.text = element_text(size=12), axis.title = element_text(size=13), legend.position="top", legend.title = element_blank(),
legend.spacing.x = unit(0.2, 'cm'), legend.text = element_text(size=12), axis.line.x = element_line(color="black", size = 0.5))
#Shapiro Wilk Test for normal distribution of BO time: significant p value means data has no normal distribution
## Have a look at the densities
ok <- na.omit(data$Botime)
plot(density(ok))
## Perform the test
shapiro.test(data$Botime)
## Plot using a qqplot
qqnorm(data$Botime);qqline(data$Botime)
# Art der schiefe der Verteilung finden -> vermutung rechtsschief
library(moments)
skewness(ok)
summary(data$Botime)
sd(data$Botime, na.rm = TRUE)
# Mixed Effects Model
m <- lme(Botime~Robotlength*View, random = ~1|Participant, data = data, method ="ML", na.action = na.omit)
summary(m)
#################### Deskriptive Roboter und Back-Off Daten #######################
###################################################################################
mean(data$Robotlength)
mean(data$Robotwidth)
mean(data$Robotheight)
mean(data$Bolength)
sd(data$Bolength)
quantile(data$Bolength, c(.5))
#quantile(data$Bolength, c(.05))
quantile(data$Bolength, c(.95))
mean(data$Bospeed)
sd(data$Bospeed)
quantile(data$Bospeed, c(.5))
mean(data$Botime, na.rm = TRUE)
sd(data$Botime, na.rm = TRUE)
quantile(data$Botime, c(.5), na.rm = TRUE)
# guten Back-off resufiltern
# nach length und time
data %>% filter(Bolength > quantile(data$Bolength, c(.95))) %>% filter(Botime > quantile(data$Botime, c(.5), na.rm = TRUE)-0.1 & Botime < quantile(data$Botime, c(.5), na.rm = TRUE)+0.1)
# nach length, speed und time
data %>% filter(Bolength > quantile(data$Bolength, c(.95))) %>% filter(Bospeed > quantile(data$Bospeed, c(.5))-0.1 & Bospeed < quantile(data$Bospeed, c(.5))+0.1) %>% filter(Botime > quantile(data$Botime, c(.5), na.rm = TRUE)-0.1 & Botime < quantile(data$Botime, c(.5), na.rm = TRUE)+0.1)
library(ggplot2)
library(readxl)
library(readr)
library(dplyr)
rm(list=ls())
(list=ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # Change WD to directory of sourcefile
setwd("06_Rohdaten")
alld<- list.files()
allp<- 1
df<- data.frame() #Hilfs-Dataframe
data<- data.frame() #Main Dataframe
# Probanden VR Daten einlesen und in df zusammenfügen
for (i in 1:50){
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # Change WD to directory of sourcefile
setwd(paste("06_Rohdaten/",alld[i], sep=''))
filename<- list.files(pattern = "\\.txt$")
dat <- read.table(filename[1], skip = 5)
dat <- cbind(dat,allp,deparse.level = 0)
dat <- cbind(dat, c(1,1,2,2,3,3,4,4,5,5),deparse.level = 0)
colnames(dat) <- c("Robotclasstemp", "Bolength", "Bospeed", "View", "Participant", "Trial")
df <- rbind(df,dat,deparse.level = 0)
allp<-allp+1
}
#Fügt eine Spalte mit Roboter Größen und eine mit Klassen hinzu
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # Change WD to directory of sourcefile
#Daten mit geometrsichen Robotergrößen einlesen
dat2 <- read.csv("Robots_LWH_.csv", header=TRUE)
#Liste für Zuordnung der geometrischen mit den klassifizierten Robotergrößen
list <- c("XS/1","XS/3","XS/5","XS/7","XS/9","XS/11","XS/13","XS/15","XS/17","XS/19","S/1","S/3","S/5","S/7","S/9","S/11","S/13","S/15","S/17","S/19",
"M/1","M/3","M/5","M/7","M/9","M/11","M/13","M/15","M/17","M/19","L/1","L/3","L/5","L/7","L/9","L/11","L/13","L/15","L/17","L/19",
"XL/1","XL/3","XL/5","XL/7","XL/9","XL/11","XL/13","XL/15","XL/17","XL/19")
#Liste für neue Klassifizierung
list2 <- c("XS","XS","XS","XS","XS","XS","XS","XS","XS","XS","S","S","S","S","S","S","S","S","S","S",
"M","M","M","M","M","M","M","M","M","M","L","L","L","L","L","L","L","L","L","L",
"XL","XL","XL","XL","XL","XL","XL","XL","XL","XL")
#Zuordnung der Robotergrößen zu Roboterklassen und zusammenführen in einem Dataframe
for (i in 1:50){
df_s <- subset(df, df$Robotclasstemp == list[i])
df_s <- cbind(df_s, subset(dat2, dat2$Robotclass == list[i]))
df_s <- cbind(df_s, list2[i])
data <- rbind(data, df_s)
}
data$Robotclasstemp <- NULL
data$Robotclass <- NULL
colnames(data) <- c("Bolength", "Bospeed", "View", "Participant", "Trial", "Robotsize", "Robotlength", "Robotwidth", "Robotheight", "Robotcategory")
# Runden
data$Bolength <- round(data$Bolength, digits=3)
# Bo Daten in Relation zur Robotergröße/Roboterlänge
data$RelBolengthRsize <- round(data$Bolength/data$Robotlength, digits=3) #BO Länge / Roboter Länge
data$RelBospeedRsize <- round(data$Bospeed/data$Robotlength, digits=3)
# Robotervolumen
data$Robotvolume <- round(data$Robotlength*data$Robotwidth*data$Robotheight, digits=3)
#Demographische Daten anbinden
dat3 <- read.csv("Demographic.csv", sep=";")
colnames(dat3) <- c("Participanttemp", "Height", "Age")
df <- data #df als temporären data.frame verwenden
df_t <- data.frame() #temporär leerer df
df_s <- data.frame() #temporär leerer ds
for (i in 1:50){
df_s <- subset(df, df$Participant == i)
df_s <- cbind(df_s, subset(dat3, dat3$Participanttemp == i))
df_t <- rbind(df_t, df_s)
}
df_t$Participanttemp <- NULL
data <- df_t
#Fragebogen Daten anbinden
dat4 <- read_excel("FragebogenTeil2.xlsx")
colnames(dat4) <- c("Participanttemp", "VRexperience", "BOlegibility", "BOandVisual" , "BOandAudio", "drop1", "drop2", "drop3", "VisualWish", "AudioWish")
dat4$drop1 <- NULL
dat4$drop2 <- NULL
dat4$drop3 <- NULL
df <- data #df als temporären data.frame verwenden
df_t <- data.frame() #temporär leerer df
df_s <- data.frame() #temporär leerer ds
for (i in 1:50){
df_s <- subset(df, df$Participant == i)
df_s <- cbind(df_s, subset(dat4, dat4$Participanttemp == i))
df_t <- rbind(df_t, df_s)
}
df_t$Participanttemp <- NULL
data <- df_t
#Größenwahrnehmung ... -1:kleiner, 0:gleich groß, 1:größer  ... als vorheriger Roboter
dat5 <- read_excel("Wahrnehmung_Groessen.xlsx")
colnames(dat5) <- c("Trialtemp", "Participanttemp", "Sizeperception", "Sizetruth" , "PerceptCorrect")
dat5$Trialtemp <- gsub("Zweiter Roboter zum Ersten", "2", dat5$Trialtemp)
dat5$Trialtemp <- gsub("Dritter Roboter zum Zweiten", "3", dat5$Trialtemp)
dat5$Trialtemp <- gsub("Vierter Roboter zum Dritten", "4", dat5$Trialtemp)
dat5$Trialtemp <- gsub("Fünfter Roboter zum Vierten", "5", dat5$Trialtemp)
for (i in  1:50){
newrow = c(1 , i , NA , NA , "TRUE")
dat5 <- rbind(dat5, newrow)
}
dat5.Trialtemp <- as.factor(dat5$Trialtemp)
dat5$Participanttemp <- as.factor(dat5$Participanttemp)
df <- data #df als temporären data.frame verwenden
df_t <- data.frame() #temporär leerer df
df_s <- data.frame() #temporär leerer df
df_x <- data.frame() #temporär leerer df
for (i in 1:50){
df_s <- subset(df, df$Participant == i)
for (j in 1:5){
df_x <- subset(df_s, df_s$Trial == j)
df_x <- cbind(df_x, subset(dat5, dat5$Participanttemp == i & dat5$Trialtemp == j))
df_t <- rbind(df_t, df_x)
}
}
df_t$Participanttemp <- NULL
df_t$Trialtemp <- NULL
data <- df_t
# Back-off Zeit einlesen und
dat6 <- read.csv("BotimeFromDistanceAndSpeed.csv", sep=",")
dat6$X <- NULL
data <- merge(data, dat6, by=c("Participant", "Trial", "View"))
# Assure that categorical factors are treated as such
# (e.g. Subject #20 is not "twice as much subject" as subject #10)
data$Participant <- as.factor(data$Participant)
# Sample
summary(data$Age)
mean(data$Age)
sd(data$Age)
summary(data$Height)
mean(data$Height)
sd(data$Height)
mean(data$VRexperience)
sd(data$VRexperience)
mean(data$BOlegibility)
sd(data$BOlegibility)
summary(data$PerceptCorrect)
# graphical inspection
ggplot(data = data, aes(y = Bolength, x = interaction(Robotcategory, View))) + geom_boxplot() + theme_bw()
# graphical check whether random slopes (cf. below) are justified
# Man sieht, dass manche Probanden generell eher hoch und manche eher tief bewerten (--> random intercept je Proband ergibt Sinn);
# Man kann auch unterschiedlichen Umgang mancher Probanden mit steigender Robotergröße, evtl auch je Blickwinkel vermuten;
# Manche steigen, manche fallen (--> random slope für die Faktoren Robotergröße und Blickwinkel ergeben vmtl. auch Sinn)
V <- subset(data, View=="V")
ggplot(data=V, aes(y=Bolength, x=interaction(Robotlength), group = Participant, fill = Participant)) + geom_line(aes(color=Participant)) + theme_bw() + labs(y="Back-off length [m] for viewpoint straight")
H <- subset(data, View=="H")
ggplot(data=H, aes(y=Bolength, x=interaction(Robotlength), group = Participant, fill = Participant)) + geom_line(aes(color=Participant)) + theme_bw() + labs(y="Back-off length [m] for viewpoint side")
# package nlme
library(nlme)
# Das ist das erste Modell, das wir implementieren, es hat random intercept für Probanden generell, aber keinen random slope
# für Probanden je Faktor
# Es hat main und interaction effects for Robotlength and View (only main effect would be: Robotlength + View)
# Alle Faktoren tragen hier signifikant bei (Sonja:"p = 0.0000 berichten als p < 0.001")
# Wie bekomme ich Effektstärke? Sonja:"standardisierte koeff. oder Slopes der Faktoren im Modell")
m2 <- lme(Bolength~Robotlength*View, random = ~1|Participant, data = data, method ="ML")
library(ggplot2)
###### EINZELN #######
rm(list=ls())
#!Funktionniert für VP 3 und aufwärts!
########################
# Proband einstellen
VP <- 18    ##############
#########################
# Trial einstellen
TR <- 2    ##############
#########################
# Blickwinkel einstellen (H/V)
View <- 'H'  ##############
#########################
# Jetzt wird eingelesen
#Liste mit Probanden erzeugen
(list=ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # Change WD to directory of sourcefile
setwd("06_Rohdaten")
ListVP <- list.files()
# BackOffs der ausgewählten Probanden aus jedem Trial in Liste schreiben
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # Change WD to directory of sourcefile
setwd(paste("06_Rohdaten/",ListVP[VP], sep=''))
# Eingewöhnung (Level1)
ListStandardBO <- list.files(pattern = "Level1")
standardBO <- read.delim(ListStandardBO[1])
# Position player
ListPositionVP <- list.files(pattern = "_player")
PositionVP <- read.delim(ListPositionVP[1])
# Position roboter
ListPositionR <- list.files(pattern = "_robot")
PositionR <- read.delim(ListPositionR[1])
# Die BackOffs aus den Einstelltrials
if(View == 'V')
{ListAllBOView<- list.files(pattern = "V_backoff")}
if(View == 'H')
{ListAllBOView<- list.files(pattern = "H_backoff")}
# spezifischen BackOff Einstellverlauf für VP, TR und Blickwinkel einlesen
BO_Speed <- read.delim(ListAllBOView[TR])
# Vorzeichen der Back-off Velocity umkehren
BO_Speed$Velocity <- BO_Speed$Velocity*(-1)
#finde den letzten BO einstell cycle
for(i in nrow(BO_Speed):1) #analysiert datensatz von hinten nach vorne
{
if (BO_Speed$Time[i] == 0.0)
{
print(i)
StartLastBO<-i
break # n <- i #speichert zeilen index das beginns des letztesn cycle in n
}
}
######
## PLOTS
#####
# plot Gewöhnungsbackoff
#plot(standardBO$Time, standardBO$Velocity, xlab="time [s]", ylab="velocity [m/s]", sub=sprintf("Standard Back-off (Gewöhnung) by participant %s", VP))
# Position VP [!nicht verwenden da Datensatz nicht über die gesamte Versuchsdauert geht!]
#plot(PositionVP$X, PositionVP$Z, xlab="X []", ylab="Y []", sub=sprintf("Position of participant %s during the experiment of total time of %s Minutes", VP, PositionVP$Time[nrow(PositionVP)]/60))
# Position Roboter [!nicht verwenden da Datensatz nicht über die gesamte Versuchsdauert geht!]
#plot(PositionR$X, PositionR$Z, xlab="X []", ylab="Y []", sub=sprintf("Position of robot in the experiment of participant %s", VP))
# plot Einstellbackoff je nach trial, und Blickwinkel
plot(BO_Speed$Time, BO_Speed$Velocity, xlab="time [s]", ylab="velocity [m/s]", col= 'grey', sub=sprintf("Back-off adjustment by participant %s in the %s condition of trial %s . The final Back-Off is black", VP, View, TR))
points(BO_Speed$Time[StartLastBO:nrow(BO_Speed)], BO_Speed$Velocity[StartLastBO:nrow(BO_Speed)], col= 'black')  # plot des letzten eingestellten BO
#####Back-off time des letzten eingestellten BO berechnen#####
lastVmax <- 0
#Ersten Zeitpunkt von BO Vmax finden
for(i in StartLastBO:nrow(BO_Speed))
{
if (i == nrow(BO_Speed))  # Wenn bis zum Ende der Aufzeichnung kein first Vmax gefunden wurde wird first und last Vmax auf ende der Aufzeichnung gesetzt
{
print("last point is mid BO")
firstVmax <- i
lastVmax <- i
break
}
else if (BO_Speed$Velocity[i+1] == BO_Speed$Velocity[i] | BO_Speed$Velocity[i+1] < BO_Speed$Velocity[i]) # für BO mit konstanter BO phase und BO ohne konstante BO phase first Vmax gefunden
{
print("firstVmax found")
firstVmax <- i
break
}
}
#letzten Zeitpunkt von BO Vmax finden nur wenn dieser noch nicht gefunden wurde
if(lastVmax == 0)
{
for(i in firstVmax:nrow(BO_Speed))
{
if (i == nrow(BO_Speed))  # Wenn bis zum Ende der Aufzeichnung kein last Vmax gefunden wurde wird last Vmax auf ende der Aufzeichnung gesetzt
{
print("last point is lastVmax")
lastVmax <- i
break
}
else if (BO_Speed$Velocity[i+1] < BO_Speed$Velocity[i])
{
print("lastVmax found")
lastVmax <- i
break
}
}
}
#Mitte des gesamten BO und total BO time berechnen
midBO <- (firstVmax+lastVmax)/2 # mitte des BO im Dataframe
mid_BO_time <- (midBO - StartLastBO)*0.1 # Zeit bis zur mitte des letzten BO
total_BO_time <- mid_BO_time*2 # Zeit bis zur mitte * 2
# Print Mitte und Ende des letzten BO
points(mid_BO_time, 0, col= 'green', cex = 1.5) # plot Back-Off Mitte des letzten BO
points(total_BO_time, 0, col= 'red', cex = 1.5) # plot Back-Off Ende des letzten BO
######################################
######################################
############### ALLE #################
######################################
######################################
rm(list=ls())
# Dataframe für Participant, Trial, View, Botime
data <- data.frame(matrix(0, ncol = 4, nrow = 500))
colnames(data) <- c("Participant", "Trial", "View", "Botime")
n <- 0
for (VP in 1:50)
{
for (TR in 1:5)
{
for (View in c("V","H"))
{
# Jetzt wird eingelesen
#Liste mit Probanden erzeugen
(list=ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # Change WD to directory of sourcefile
setwd(paste("06_Rohdaten/",alld[i], sep=''))
ListVP <- list.files()
# BackOffs der ausgewählten Probanden aus jedem Trial in Liste schreiben
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # Change WD to directory of sourcefile
setwd(paste("06_Rohdaten/",alld[i], sep=''))
# Die BackOffs aus den Einstelltrials
if(View == 'V')
{ListAllBOView<- list.files(pattern = "V_backoff")}
if(View == 'H')
{ListAllBOView<- list.files(pattern = "H_backoff")}
# spezifischen BackOff Einstellverlauf für VP, TR und Blickwinkel einlesen
if (file.exists(ListAllBOView[TR]))   # Nur versuchen einzulesen falls Datai des spez. Trial vorhanden ist
{
BO_Speed <- read.delim(ListAllBOView[TR])
# Vorzeichen der Back-off Velocity umkehren
BO_Speed$Velocity <- BO_Speed$Velocity*(-1)
#finde den letzten BO einstell cycle
for(i in nrow(BO_Speed):1) #analysiert datensatz von hinten nach vorne
{
if (BO_Speed$Time[i] == 0.0)
{
StartLastBO<-i
break # n <- i #speichert zeilen index das beginns des letztesn cycle in n
}
}
#####Back-off time des letzten eingestellten BO berechnen#####
lastVmax <- 0
#Ersten Zeitpunkt von BO Vmax finden
for(i in StartLastBO:nrow(BO_Speed))
{
if (i == nrow(BO_Speed))  # Wenn bis zum Ende der Aufzeichnung kein first Vmax gefunden wurde wird first und last Vmax auf ende der Aufzeichnung gesetzt
{
#print("last point is mid BO")
firstVmax <- i
lastVmax <- i
break
}
else if (BO_Speed$Velocity[i+1] == BO_Speed$Velocity[i] | BO_Speed$Velocity[i+1] < BO_Speed$Velocity[i]) # für BO mit konstanter BO phase und BO ohne konstante BO phase first Vmax gefunden
{
#print("firstVmax found")
firstVmax <- i
break
}
}
#letzten Zeitpunkt von BO Vmax finden nur wenn dieser noch nicht gefunden wurde
if(lastVmax == 0)
{
for(i in firstVmax:nrow(BO_Speed))
{
if (i == nrow(BO_Speed))  # Wenn bis zum Ende der Aufzeichnung kein last Vmax gefunden wurde wird last Vmax auf ende der Aufzeichnung gesetzt
{
#print("last point is lastVmax")
lastVmax <- i
break
}
else if (BO_Speed$Velocity[i+1] < BO_Speed$Velocity[i])
{
#print("lastVmax found")
lastVmax <- i
break
}
}
}
#Mitte des gesamten BO und total BO time berechnen
midBO <- (firstVmax+lastVmax)/2 # mitte des BO im Dataframe
mid_BO_time <- (midBO - StartLastBO)*0.1 # Zeit bis zur mitte des letzten BO
total_BO_time <- mid_BO_time*2 # Zeit bis zur mitte * 2
# Daten in ein dataframe schreiben
n <- n+1
data$Participant[n] <- VP
data$Trial[n] <- TR
data$View[n] <- View
data$Botime[n] <- total_BO_time
print(sprintf("Participant %s, in Trial %s, with View %s likes a back-off time of %s seconds. This is now row %s", VP, TR, View, total_BO_time, n))
}
else      # Wenn Datei für spez. Trial nicht vorhanden
{
total_BO_time <- NaN
n <- n+1
data$Participant[n] <- VP
data$Trial[n] <- TR
data$View[n] <- View
data$Botime[n] <- total_BO_time
print(sprintf("Participant %s, in Trial %s, with View %s likes a back-off time of %s seconds. This is now row %s", VP, TR, View, total_BO_time, n))
}
}
}
}
# nach visuellem Abgleich BOtime mit erhobenen BO Daten werden offensichtlich fehlerhaft abgespeicherte finale BOs aussortiert (VP: 16T1H)
data$Botime[152] <- NaN # BOtime von 0s ist unmöglich
# BOtime speichern
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # Change WD to directory of sourcefile
write.csv(data, file = "BotimeFromDistanceAndSpeed.csv")
####### test BOtime count
ggplot(data = data, aes(x = Botime)) +
geom_histogram(binwidth= 0.2)+
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(),
axis.text = element_text(size=12), axis.title = element_text(size=13), legend.position="top", legend.title = element_blank(),
legend.spacing.x = unit(0.2, 'cm'), legend.text = element_text(size=12), axis.line.x = element_line(color="black", size = 0.5))
